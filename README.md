# Introduction to the gem5 emulator

This report is part of the assignment for the course *Computer Architecture and Accelerators* at the *Aristotle University of Thessaloniki*. The purpose of this assignment is to provide an introduction to the gem5 simulator, a widely used tool in computer architecture research.

## Part 1 - Introduction to gem5 and Hello World

### Question 1

The `starter_se.py` script configures a system for **syscall emulation (SE) mode** in gem5, where user-level applications are executed without a full operating system. The main parameters of the simulated system are summarized below.

#### **CPU Configuration**

- **CPU Model**: `MinorCPU`
- **Number of cores**: 1 (default value of `--num-cores`)
- **CPU frequency**: 1 GHz (default value of `--cpu-freq`)
- **Voltage**: 1.2 V

The CPU is created as part of a `CpuCluster`, which allows support for multi-core configurations, although only one core is used in this example.

#### **Cache hierarchy**

The cache hierarchy is enabled because the `MinorCPU` model operates in timing memory mode, which allows detailed modeling of cache and memory access latencies.

- **Cache line size**: 64 bytes
- **L1 Instruction Cache (L1I)**: enabled
- **L1 Data Cache (L1D)**: enabled
- **L2 Cache**: enabled and shared across the CPU cluster
- **TLB walk cache**: enabled

#### **Memory system**

- **Main memory type**: `DDR3_1600_8x8` (default value of `--mem-type`)
- **Memory size**: 2 GB (default value of `--mem-size`)
- **Memory channels**: 2 (default value of `--mem-channels`)
- **Memory bus**: SystemXBar (system crossbar interconnect)

The main memory is configured using the `MemConfig.config_mem()` helper function, which instantiates the selected DRAM model, connects it to the system bus, and maps it into the systemâ€™s physical address space.

#### **Clock and voltage**

- **System clock**: 1 GHz
- **System voltage**: 3.3 V

### Question 2

**a)** The `config.json` file generated by gem5 provides a detailed representation of the simulated system. By inspecting this file, we can verify the parameters identified in the previous question.

#### **CPU Configuration**

- **CPU Model**: `system > cpu_cluster > cpus > type`
- **Number of cores**: `system > cpu_cluster > cpus` (the list contains 1 object)
- **CPU frequency**: `system > cpu_cluster > clk_domain > clock`
- **Voltage**: `system > cpu_cluster > voltage_domain > voltage`

#### **Cache hierarchy**

- **Cache line size**: `system > cache_line_size`
- **L1 Instruction Cache (L1I)**: `system > cpu_cluster > cpus > icache`
- **L1 Data Cache (L1D)**: `system > cpu_cluster > cpus > dcache`
- **L2 Cache**: `system > cpu_cluster > l2`
- **TLB walk cache**: `system > cpu_cluster > cpus > itb_walker_cache`

#### **Memory system**

- **Main memory type**: `system > mem_ctrls > type`
- **Memory size**: `system > mem_ranges` (range from 0 to 2,147,483,647)
- **Memory channels**: `system > memories` (**2 memory controllers** in the list, each one manage a channel of RAM)
- **Memory bus**: `system > membus > type`

#### **Clock and voltage**

- **System clock**: `system > clk_domain > clock`
- **System voltage**: `system > voltage_domain > voltage`

**b)** The `stats.txt` file contains several metrics that describe the execution of the simulation.

- **sim_seconds**: Represents the total execution time of the program on the simulated system, measured in seconds. For the `hello-world` program, this is 0.000035 sec.
- **sim_ticks**: Indicates the total number of simulation ticks elapsed during execution. In gem5, one tick corresponds to one picosecond. For `hello-world` program, this is 35,452,000 ticks.
- **sim_insts**: The total number of instructions executed by the simulated CPU during the simulation. For `hello-world` program, this is 5,043 instructions.
- **host_inst_rate**: Describes the rate at which instructions are simulated on the host machine, reflecting the speed of the simulation rather than the performance of the simulated architecture. For `hello-world` program, this is 213,437 instruction per second.

**d)** In `stats.txt`, the total number of cache accesses can be found at:  

- **L1 Data Cache:** `system.cpu_cluster.cpus.dcache.overall_accesses::total`  
- **L2 Cache:** `system.cpu_cluster.l2.overall_accesses::total`  

For the `hello-world` program, the values are:  

- **L1 Data Cache accesses:** 2,185  
- **L2 Cache accesses:** 475  

If the total number of accesses is not directly reported, it can be calculated using the number of hits and misses:  

$$
\text{Total Accesses} = \text{Hits} + \text{Misses}
$$

**Examples:**  

- **L1 D-Cache:**  
  - Hits: 2,006 (`system.cpu_cluster.cpus.dcache.overall_hits::total`)  
  - Misses: 179 (`system.cpu_cluster.cpus.dcache.overall_misses::total`) 

- **L2 Cache:**  
  - Hits: 0
  - Misses: 475 (`system.cpu_cluster.l2.overall_misses::total`)
